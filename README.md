# core

# 仕様

## ISA
+ RISC-Vベース
    + RV32I (一部未実装)
    + RV32M (一部未実装)
    + RV32D (一部未実装)
    + `FROUNDRM`系(RV32Dに追加) : 浮動小数点数整数化丸め用の命令
        + `FFLOOR` : 切り捨て
    + `IN`系・`OUT`系(カスタム) : UARTによる入出力用の命令
        + `INW` : 32bit整数の入力
        + `INF` : 32bit浮動小数点数の入力
        + `OUTW` : 32bit整数の出力
        + `OUTB` : 8bit整数の出力

## データの種類
+ 命令 : 32bit
    + 形式的には16bit単位の可変長
    + 32bitのものしか使っていない
+ 整数および汎用
    + byte : 8bit
    + word : 32bit
+ 浮動小数点数
    + float : 32bit

## レジスタ
+ 32bit整数用 : 32個
    + 0番 : ゼロレジスタ
    + コンパイラの用法
        + 1番 : リンクレジスタ(caller save)
            + 0で初期化
        + 2番 : スタックポインタ(caller save)
            + メモリサイズで初期化
        + 3番 : ヒープポインタ
            + 0で初期化
        + 4番 : 返り値(caller save)
            + 0で初期化(以下すべて0)
        + 4~29番 : 引数(caller save)
        + 30~31番 : 一時変数(関数呼び出しで保存されない)
+ 32bit浮動小数点数用 : 32個
    + 0で初期化

## メモリ
+ 命令メモリ : 256KB
    + アドレスは32bit
        + 上位14bitは無視
    + アクセスはバイトアドレッシング
        + 1命令ごとにアドレスが4つ増える
        + PCの下位2ビットは更新時に無視する
    + 実装は32bitデータのメモリ
+ データメモリ : 2MB
    + アドレスは32bit
        + 上位11bitは無視
    + バイトアドレッシング(実際にはWord単位でのアクセスのみ実装)
    + ビッグエンディアン

## その他
+ プログラムローダ機能(SW8)
+ 実行開始ボタン(SW10)
    + SW10を押し、離すと実行
    + SW8を押し、離すとプログラムローダモード
    + SW10とSW8は、リセットボタンとしても利用可能
+ パイプラインなし

-------------------------------

# ステージ構造

## ステージ間レジスタの有無によるステージの分け方
+ fetch(F)
    + 命令メモリから命令を取り出して**キャッシュする**
+ decode(レジスタ解決なし)(D1)
    + **デコードするPCを決める**
        + パイプライン化のため
        + 分岐予測をするので、制御ハザードが起きた時にはEステージの結果をステージ間レジスタを介さずに使う
    + **Fステージのキャッシュから命令をとってくる**
    + 命令を解析する
+ decode(レジスタ解決)(D2)
    + レジスタから値を受け取る
    + 命令が実行できるかどうかを判断する
    + 命令を実行する順番を決める
        + Out of Order実行のため(現在は未実装)
+ execute(E)
    + 実行する
    + 次に実行する命令のPCが正式に決まる
+ write(W)
    + 結果をレジスタに書き込む

## ステージの役割をするモジュール一覧
### fetch(f) : 命令の取得、キャッシュ(F,D1)
+ 次のPCを予測もしくは取得して、命令メモリからキャッシュに入れる(F)
+ 要求されたPCの命令をキャッシュから引く(D1)

### context manage(c) : 実行文脈の管理(D1)
+ 分岐予測
    + 条件分岐命令の各分岐(文脈)に対して次に実行すべき命令のPCを集めて置き、一括して管理する
    + 条件分岐命令をデコードするときに新しい文脈を与える
    + 各文脈に対して、採用されなかったら一緒にフラッシュする文脈を記憶しておく
+ 現在実行もしくは予測している文脈から、次に読み込む文脈と命令を決定し、fに要求する(D1)

### decode(d) : 命令の解釈(D1,E)
+ 与えられた命令の機械語を解析する(D1)
+ 次のPC(の候補)がわかる場合は先に後述のcにそれを与える(E)

### register manage(r) : レジスタの管理(D2,W)
+ レジスタの値を読み込む(D2)
+ 実行の結果を書き込む(W)
+ フォーワーディング(W/D2)
+ 仮想レジスタアドレスを物理レジスタアドレスに変換(現状は両方同じもの)

### exec(e) : 命令の実行(E)
+ 命令を実行する(E)
+ 条件分岐命令は、PCの代わりに実行文脈の候補を受け取り、採用された文脈と採用されなかった文脈を返す

### instruction window(i) : デコード済み命令の管理(D2)
+ レジスタ解決の結果を管理
+ 命令が実行できるかの判断や、(OoO実装後は)実行順を決定する(D2)


## 各ステージの実行順序

### F : f
0. クロック
1. 命令メモリに命令データを要求(f)
    + 要求するPCの決め方
        + 直前に要求した命令の次の命令
        + リンクレジスタの値
2. nクロック(命令を得るまで待つ)
3. 得たデータをキャッシュに入れる(f)

### E/W : i → e → r(,c)
1. 1クロックで終わるとき

    0. クロック
    1. 実行する命令を得る(i)
    2. 実行(e)
    3. 必要なら結果をcに送る(e)
        + `JALR`のとき
        + 条件分岐命令のとき
            + どちらもすぐに実行できるので問題ない
    4. 実行結果をレジスタに入れる(r)
    5. D1ステージの3とD2/Wステージ5のへ

2. 2クロック以上でかかるとき

    0. クロック
    1. 実行する命令を得る(i)
    2. 実行(e)
    3. nクロック(実行が終了するまで)
    4. 実行結果をレジスタに入れる(r)
    5. D2/Wステージの5へ

### D1 : (e →) c → f → d → i,c
0. クロック
1. (Eステージ)条件分岐命令の結果を取得(e)
2. (Eステージ)デコード時に決定しなかったPC情報を決定(e)
3. 制御ハザードの実行に従って全体にフラッシュの指示を出し、文脈の情報を更新(c)
4. 次に読むべきPCを決定(c)
5. PCから命令のデータを得る(f)
6. 命令を解析(d)
7. i内のレジスタに入れる(i)
8. 次のPC(の候補)の値が決まった場合、cに送る(d)
    + 次の命令が順番で実行されるとき
    + `JAL`命令のとき(PCと即値で決まる)
    + 条件分岐命令のとき(次の命令か、即値だけ進めた命令)
    + `JALR`命令はレジスタの値が必要になるので決まらない
9. 8に基づいて文脈情報を更新する(c)
10. 複数命令をデコードするときは4から9を繰り返す
11. 次に取得すべきPCのヒントを与える(c)

### D2/W : i → (e →) r → i
0. クロック
1. 実行が開始された、またはフラッシュされた命令を除く(i)
2. 命令一覧を整理する(i)
3. 制御ハザードが起こったとき、捨てるべき命令を消す(i/r)
4. (Eステージ)実行結果を得る(e)
5. 実行結果を整理する(r)
6. レジスタの値を与えられれば与える(r)
7. 次のクロックで実行する命令を選ぶ(i)

-------------------------------

# モジュール間のタイミングの取り方

## CPU

パイプライン時のステージ間のレジスタの管理をして、下位のモジュールに指示を出すのが役割  

+ **クロックに同期して**小さな処理を開始し、
+ **そのまま**下位のモジュールに仕事を投げ、
+ 出力されたものを**クロックと同期して**受け取る

ので、下位のモジュールは、

+ cpuから送られてきた`order`を受け取ったあと、**次のクロックを待たずに処理を開始**してしまったほうが良い
+ 出力も、**最終クロックの初めに**(1クロックで終わるなら入力を認識した直後に)`done`**を上げて**、**クロックを待たずに出力する**ほうが望ましい

## メモリ

+ クロック同期でアドレスなどを読み込み、
+ そのクロックのうちに実行し、
+ 次のクロックで出力開始する

ので、アクセスするときには、

+ `order`同期の信号をそのまま送り(1クロック)、
+ 1クロック待ち(2クロック)、
+ メモリの出力とモジュールの出力をつなげる(3クロック)

## レジスタを使用する記憶用モジュール

レジスタを使うときには、

+ クロック同期で入力を代入し、
+ 出力は同期せずにできる
    + が、独立した作業をさせる場合にはクロック同期で出力するようにする

ので、`order`等を使って呼び出すときには、

+ クロックと同期せずに入力して、
+ クロックを待たずに`accepted`や`done`を確認し次第`order`を取り下げる
